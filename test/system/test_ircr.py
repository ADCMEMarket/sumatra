"""
A run through of basic Sumatra functionality.

As our example code, we will use a Python program for analyzing scanning
electron microscope (SEM) images of glass samples. This example was taken from
an online SciPy tutorial at http://scipy-lectures.github.com/intro/summary-exercises/image-processing.html

Usage:
    nosetests -v ircr.py
or:
    python ircr.py
"""

# Requirements: numpy, scipy, matplotlib, mercurial, sarge
import os
import tempfile
import shutil
import re
from itertools import islice, izip
from datetime import datetime
import sarge

repository = "https://bitbucket.org/apdavison/ircr2013"
#repository = "/Volumes/USERS/andrew/dev/ircr2013"  # during development
#repository = "/Users/andrew/dev/ircr2013"

label_pattern = re.compile("Record label for this run: '(?P<label>\d{8}-\d{6})'")
label_pattern = re.compile("Record label for this run: '(?P<label>[\w\-_]+)'")

info_pattern = r"""Project name        : (?P<project_name>\w+)
Default executable  : (?P<executable>\w+) \(version: \d.\d.\d\) at /[\w\/]+/bin/python
Default repository  : MercurialRepository at \S+/sumatra_exercise \(upstream: \S+/ircr2013\)
Default main file   : (?P<main>\w+.\w+)
Default launch mode : serial
Data store \(output\) : /[\w\/]+/sumatra_exercise/Data
.          \(input\)  : /[\w\/]+/sumatra_exercise
Record store        : Relational database record store using the Django ORM \(database file=/[\w\/]+/sumatra_exercise/.smt/records\)
Code change policy  : (?P<code_change>\w+)
Append label to     : None
Label generator     : timestamp
Timestamp format    : %Y%m%d-%H%M%S
Sumatra version     : 0.6.0dev
"""

record_pattern = re.compile(r"""Label            : (?P<label>[\w-]+)
Timestamp        : (?P<timestamp>.*)
Reason           : *(?P<reason>.*)
Outcome          : *(?P<outcome>.*)
Duration         : (?P<duration>\d+.\d*)
Repository       : (?P<vcs>\w+)Repository at .*
.*
Main_File        : (?P<main>\w+.\w.)
Version          : (?P<version>\w+)
Script_Arguments : *(?P<script_args>.*)
Executable       : (?P<executable_name>\w+) \(version: (?P<executable_version>[\w\.]+)\) at (?P<executable_path>.*)
Parameters       : *(?P<parameters>.*)
""")  # TO COMPLETE

temporary_dir = None
working_dir = None
labels = []


def pairs(iterable):
    """
    ABCDEF -> (A, B), (C, D), (E, F)
    """
    return izip(islice(iterable, 0, None, 2), islice(iterable, 1, None, 2))


def setup():
    """Create temporary directory for the Sumatra project."""
    global temporary_dir, working_dir, labels
    temporary_dir = os.path.realpath(tempfile.mkdtemp())
    working_dir = os.path.join(temporary_dir, "sumatra_exercise")
    os.mkdir(working_dir)
    print working_dir
    labels = []


def teardown():
    """Delete all files."""
    if os.path.exists(temporary_dir):
        shutil.rmtree(temporary_dir)


def run(command):
    """Run a command in the Sumatra project directory and capture the output."""
    return sarge.run(command, cwd=working_dir, stdout=sarge.Capture())


def get_label(p):
    """Obtain the label generated by 'smt run'."""
    match = label_pattern.search(p.stdout.text)
    if match is not None:
        return match.groupdict()["label"]
    else:
        return None


def assert_in_output(p, texts):
    """Assert that the stdout from process 'p' contains all of the provided text."""
    if isinstance(texts, basestring):
        texts = [texts]
    for text in texts:
        assert text in p.stdout.text, "'{}' is not in '{}'".format(text, p.stdout.text)


def assert_config(p, expected_config):
    """Assert that the Sumatra configuration (output from 'smt info') is as expected."""
    match = re.match(info_pattern, p.stdout.text)
    assert match
    for key, value in expected_config.items():
        assert match.groupdict()[key] == value, "expected {} = {}, actually {}".format(key, value, match.groupdict()[key])


def assert_records(p, expected_records):
    """ """
    matches = [match.groupdict() for match in record_pattern.finditer(p.stdout.text)]
    match_dict = {match["label"]: match for match in matches}
    for record in expected_records:
        matching_record = match_dict[record["label"]]
        for key in record:
            assert record[key] == matching_record[key]


def assert_file_exists(p, relative_path):
    """Assert that a file exists at the given path, relative to the working directory."""
    assert os.path.exists(os.path.join(working_dir, relative_path))


def assert_label_equal(p, expected_label):
    """ """
    assert get_label(p) == expected_label


def expected_short_list(labels):
    """Generate the expected output from the 'smt list' command, given the list of captured labels."""
    return "\n".join(reversed(labels))


def substitute_labels(expected_records):
    """ """
    def wrapped(labels):
        for record in expected_records:
            index = record["label"]
            record["label"] = labels[index]
        return expected_records
    return wrapped


def build_command(template):
    """Return a function which will return a string."""
    def wrapped(args):
        return template.format(*args)
    return wrapped


def edit_parameters(input, output, name, new_value):
    """ """
    def wrapped():
        with open(os.path.join(working_dir, input), 'rb') as fpin:
            with open(os.path.join(working_dir, output), 'wb') as fpout:
                for line in fpin:
                    if name in line:
                        fpout.write("{} = {}\n".format(name, new_value))
                    else:
                        fpout.write(line)
    return wrapped


def modify_script(filename):
    def wrapped():
        with open(os.path.join(working_dir, filename), 'rb') as fp:
            script = fp.readlines()
        with open(os.path.join(working_dir, filename), 'wb') as fp:
            for line in script:
                if "print mean_bubble_size, median_bubble_size" in line:
                    fp.write('print "Mean:", mean_bubble_size\nprint "Median:", median_bubble_size\n')
                else:
                    fp.write(line)
    return wrapped


def run_test(command, *checks):
    """Execute a command in a sub-process then check that the output matches some criterion."""
    global labels
    if callable(command):
        command = command(labels)
    p = run(command)
    for check, checkarg in pairs(checks):
        if callable(checkarg):
            checkarg = checkarg(labels)
        check(p, checkarg)
    label = get_label(p)
    if label is not None:
        labels.append(label)
        print "label is", label
run_test.__test__ = False  # nose should not treat this as a test


test_steps = [
    ("Get the example code",
     "hg clone %s ." % repository,
     assert_in_output, "updating to branch default"),
    ("Run the computation without Sumatra",
     "python glass_sem_analysis.py default_parameters MV_HFV_012.jpg",
     assert_in_output, "2416.86315789 60.0",
     assert_file_exists, os.path.join("Data", datetime.now().strftime("%Y%m%d")),  # Data subdirectory contains another subdirectory labelled with today's date)
     ),  #assert(subdirectory contains three image files).
    ("Set up a Sumatra project",
     "smt init -d Data -i . ProjectGlass",
     assert_in_output, "Sumatra project successfully set up"),
    ("Run the ``glass_sem_analysis.py`` script with Sumatra",
     "smt run -e python -m glass_sem_analysis.py -r 'initial run' default_parameters MV_HFV_012.jpg",
     assert_in_output, ("2416.86315789 60.0", "Created Django record store using SQLite", "histogram.png")),
    ("Comment on the outcome",
     "smt comment 'works fine'"),
    ("Set defaults",
     "smt configure -e python -m glass_sem_analysis.py"),
    ("Look at the current configuration of the project",
     "smt info",
     assert_config, {"project_name": "ProjectGlass", "executable": "Python", "main": "glass_sem_analysis.py",
                     "code_change": "error"}),
    edit_parameters("default_parameters", "no_filter", "filter_size", 1),
    ("Run with changed parameters and user-defined label",
     "smt run -l example_label -r 'No filtering' no_filter MV_HFV_012.jpg",  # TODO: assert(results have changed)
     assert_in_output, "phases.png",
     assert_label_equal, "example_label"),
    ("Change parameters from the command line",
     "smt run -r 'Trying a different colourmap' default_parameters MV_HFV_012.jpg phases_colourmap=hot"),  # assert(results have changed)
    ("Add another comment",
     "smt comment 'The default colourmap is nicer'"),  #TODO  add a comment to an older record (e.g. this colourmap is nicer than 'hot')")
    ("Add tags on the command line",
     build_command("smt tag mytag {0} {1}")),
    modify_script("glass_sem_analysis.py"),
    ("Run the modified code",
     "smt run -r 'Added labels to output' default_parameters MV_HFV_012.jpg",
     assert_in_output, "Code has changed, please commit your changes"),
    ("Commit changes...",
     "hg commit -m 'Added labels to output'"),
    ("...then run again",
     "smt run -r 'Added labels to output' default_parameters MV_HFV_012.jpg"),  # assert(output has changed as expected)
    #TODO: make another change to the Python script
    ("Change configuration to store diff",
     "smt configure --on-changed=store-diff"),
    ("Run with store diff",
     "smt run -r 'made a change' default_parameters MV_HFV_012.jpg"),  # assert(code runs, stores diff)
    ("Review previous computations - get a list of labels",
     "smt list",
     assert_in_output, expected_short_list),
    ("Review previous computations in detail",
     "smt list -l",
     assert_records, substitute_labels([
         {'label': 0, 'executable_name': 'Python', 'outcome': 'works fine', 'reason': 'initial run',
          'version': 'a98585eddfc7', 'vcs': 'Mercurial', 'script_args': '<parameters> MV_HFV_012.jpg',
          'main': 'glass_sem_analysis.py'},   # TODO: add checking of parameters
         {'label': 1, 'outcome': '', 'reason': 'No filtering'},
         {'label': 2, 'outcome': 'The default colourmap is nicer', 'reason': 'Trying a different colourmap'},
         {'label': 3, 'outcome': '', 'reason': 'Added labels to output'},
         {'label': 4, 'outcome': '', 'reason': 'made a change'},  # TODO: add checking of diff
     ])),
    ("Filter the output of ``smt list`` based on tag",
     "smt list mytag",
     #assert(list is correct)
    ),
    ("Export Sumatra records as JSON.",
     "smt export",
     assert_file_exists, ".smt/records_export.json"),
]


def test_all():
    """Test generator for Nose."""
    for step in test_steps:
        if callable(step):
            step()
        else:
            run_test.description = step[0]
            yield tuple([run_test] + list(step[1:]))

# Still to test:
#
#.. LaTeX example
#.. note that not only Python is supported - separate test
#.. play with labels? uuid, etc.
#.. move recordstore
#.. migrate datastore


if __name__ == '__main__':
    # Run the tests without using Nose.
    setup()
    for step in test_steps:
        if callable(step):
            step()
        else:
            print step[0]  # description
            run_test(*step[1:])
    response = raw_input("Do you want to delete the temporary directory? ")
    if response in ["y", "Y", "yes"]:
        teardown()
    else:
        print "Temporary directory %s not removed" % temporary_dir
